// public/calculation.worker.js
// (Or configure your bundler for worker imports)

// --- START: Copy these helper functions directly into the worker file ---
const parseAndFormat = (value) => {
  const num = parseFloat(value);
  return isNaN(num) ? '0.00' : num.toFixed(2);
};

const baseFieldKeys = [
  'stcNstaff', 'offResidenceA', 'otherPremisesA', 'electricFitting', 'totalA',
  'computers', 'compSoftwareInt', 'compSoftwareNonint', 'compSoftwareTotal', 'motor',
  'offResidenceB', 'stcLho', 'otherPremisesB', 'otherMachineryPlant', 'totalB',
  'totalFurnFix', 'landNotRev', 'landRev', 'landRevEnh', 'offBuildNotRev',
  'offBuildRev', 'offBuildRevEnh', 'residQuartNotRev', 'residQuartRev', 'residQuartRevEnh',
  'premisTotal', 'revtotal', 'totalC', 'premisesUnderCons', 'grandTotal',
];

const nonTotalBaseFieldKeys = [
  'stcNstaff', 'offResidenceA', 'otherPremisesA', 'electricFitting',
  'computers', 'compSoftwareInt', 'compSoftwareNonint', 'motor',
  'offResidenceB', 'stcLho', 'otherPremisesB',
  'landNotRev', 'landRev', 'landRevEnh', 'offBuildNotRev', 'offBuildRev',
  'offBuildRevEnh', 'residQuartNotRev', 'residQuartRev', 'residQuartRevEnh',
  'premisesUnderCons',
];

const calculateRowTotals = (data, suffix) => {
  const updatedData = { ...data };
  const p = (fieldPath) => parseFloat(updatedData[fieldPath]) || 0;

  updatedData[`totalA${suffix}`] = parseAndFormat(
    p(`stcNstaff${suffix}`) +
    p(`offResidenceA${suffix}`) +
    p(`otherPremisesA${suffix}`) +
    p(`electricFitting${suffix}`)
  );
  updatedData[`compSoftwareTotal${suffix}`] = parseAndFormat(
    p(`compSoftwareInt${suffix}`) + p(`compSoftwareNonint${suffix}`)
  );
  updatedData[`otherMachineryPlant${suffix}`] = parseAndFormat(
    p(`offResidenceB${suffix}`) + p(`stcLho${suffix}`) + p(`otherPremisesB${suffix}`)
  );
  updatedData[`totalB${suffix}`] = parseAndFormat(
    p(`computers${suffix}`) +
    p(updatedData[`compSoftwareTotal${suffix}`]) +
    p(`motor${suffix}`) +
    p(updatedData[`otherMachineryPlant${suffix}`])
  );
  updatedData[`totalFurnFix${suffix}`] = parseAndFormat(
    p(updatedData[`totalA${suffix}`]) + p(updatedData[`totalB${suffix}`])
  );
  updatedData[`premisTotal${suffix}`] = parseAndFormat(
    p(`landNotRev${suffix}`) +
    p(`landRev${suffix}`) +
    p(`offBuildNotRev${suffix}`) +
    p(`offBuildRev${suffix}`) +
    p(`residQuartNotRev${suffix}`) +
    p(`residQuartRev${suffix}`)
  );
  updatedData[`revtotal${suffix}`] = parseAndFormat(
    p(`landRevEnh${suffix}`) + p(`offBuildRevEnh${suffix}`) + p(`residQuartRevEnh${suffix}`)
  );
  updatedData[`totalC${suffix}`] = parseAndFormat(
    p(updatedData[`premisTotal${suffix}`]) + p(updatedData[`revtotal${suffix}`])
  );
  updatedData[`grandTotal${suffix}`] = parseAndFormat(
    p(updatedData[`totalA${suffix}`]) +
    p(updatedData[`totalB${suffix}`]) +
    p(updatedData[`totalC${suffix}`]) +
    p(`premisesUnderCons${suffix}`)
  );
  return updatedData;
};

const sumAcrossRows = (data, fieldBaseName, suffixesToSum) => {
  let total = 0;
  suffixesToSum.forEach((sfx) => {
    total += parseFloat(data[`${fieldBaseName}${sfx}`]) || 0;
  });
  return parseAndFormat(total);
};

const subtractAcrossRows = (data, fieldBaseName, minuendSuffix, subtrahendSuffix) => {
  const minuend = parseFloat(data[`${fieldBaseName}${minuendSuffix}`]) || 0;
  const subtrahend = parseFloat(data[`${fieldBaseName}${subtrahendSuffix}`]) || 0;
  return parseAndFormat(minuend - subtrahend);
};
// --- END: Copied helper functions ---

// Main calculation function (must be self-contained or have dependencies here)
const performAllCalculations = (initialData) => {
  let calculatedData = { ...initialData };
  const p = (fieldPath) => parseFloat(calculatedData[fieldPath]) || 0;

  const editableRowSuffixes = [
    '1', '3', '4', '5', '6', '9', '10', '11', '18', '19', '20', '21',
    '24', '25', '26', '30', '33', '34', '35', '36', '37', '38', '39', '40',
  ];

  editableRowSuffixes.forEach((suffix) => {
    calculatedData = calculateRowTotals(calculatedData, suffix);
  });

  nonTotalBaseFieldKeys.forEach((key) => {
    calculatedData[`${key}7`] = sumAcrossRows(calculatedData, key, ['3', '4', '36', '5', '6']);
    calculatedData[`${key}12`] = sumAcrossRows(calculatedData, key, ['37', '9', '33', '10', '11']);
    calculatedData[`${key}13`] = subtractAcrossRows(calculatedData, key, '7', '12');
    calculatedData[`${key}14`] = sumAcrossRows(calculatedData, key, ['1', '13']);
    calculatedData[`${key}22`] = sumAcrossRows(calculatedData, key, ['18', '34', '38', '19', '20', '21', '39']);
    calculatedData[`${key}27`] = sumAcrossRows(calculatedData, key, ['40', '24', '25', '26']);
    calculatedData[`${key}28`] = subtractAcrossRows(calculatedData, key, '22', '27');
    calculatedData[`${key}29`] = subtractAcrossRows(calculatedData, key, '14', '28');
    calculatedData[`${key}31`] = subtractAcrossRows(calculatedData, key, '9', '24');

    const val30 = p(`${key}30`);
    const val31 = p(calculatedData[`${key}31`]);
    const val35 = p(`${key}35`);
    calculatedData[`${key}32`] = parseAndFormat(val30 - (val31 + val35));
  });

  const aggregatedRowSuffixes = ['7', '12', '13', '14', '22', '27', '28', '29', '31', '32'];
  aggregatedRowSuffixes.forEach((suffix) => {
    calculatedData = calculateRowTotals(calculatedData, suffix);
  });

  return calculatedData;
};

self.onmessage = function(event) {
  const { type, data } = event.data;
  if (type === 'CALCULATE') {
    const result = performAllCalculations(data);
    self.postMessage({ type: 'CALCULATE_COMPLETE', data: result });
  }
};
